<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>快速排序</title>
</head>
<body>
    <script>
        /* 
            quick：实现快速排序
                @params
                    ary [Array] 需要排序的数据
                @return
                    [Array] 排序后的新数组
            by candy on 2020/08/20
         */
        function quick(ary){
            //4 结束递归（当Ary小于等于1项，则不处理）
            if(ary.length<=1){
                return ary;
            }
            //1 找到数组的中间项，在原有的数据中把它移除
            let middleIndex=Math.floor(ary.length/2);
            let middleValue=ary.splice(middleIndex,1)[0];

            //准备左右两个数组，循环剩下两个数组的每一项，比当前项小的放到左边数组中，反之放到右边数组中
            let leftAry=[],
                rightAry=[];
            for(let i=0;i<ary.length;i++){
                let item=ary[i];
                item<middleValue?leftAry.push(item):rightAry.push(item);
            }
            //3.递归方式让左右两边持续这种处理，一直到左右两边都排好序位置（最后）
            return quick(leftAry).concat(middleValue,quick(rightAry))
        }
        let ary=[12,8,15,16,1,24];
        ary=quick(ary);
        console.log(ary);

        // 递归：函数执行的时候自己调用自己
        /* function fn(){
            fn();
            //Uncaught RangeError: Maximum call stack size exceeded
            //这种死递归会导致栈溢出
        }; */
        /* function fn(){
            setTimeout(fn,0);
            //这种看似像死递归的方法不会导致栈溢出的错误
        }
        fn(); */
        //获取1-10的和
        /* let total=null;
        for(let i=0;i<=10;i++){
            total+=i;
        }
        console.log(total); */
        function sum(n){
            if(n>10){
                return 0;
            }
            return n+sum(n+1);
        }
        //return 1+2+3+4+5+6+7+8+9+10+sum(11);
        let total=sum(1);
    </script>
</body>
</html>